<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<!--<meta charset="utf-8">-->
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CNDP: lib/usr/clib/cthread/cthread_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="/assets/css/styles.css" rel="stylesheet" type="text/css" />
<link href="/assets/css/custom_doxygen.css" rel="stylesheet" type="text/css" />
<link href="/assets/images/favicon.png" rel="icon" type="image/x-icon">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
</head>
<body>
<nav class="navbar navbar-expand-md navbar-dark bg-blue px-2">
  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="/" aria-label="CNDP">
    <img src="/assets/images/CNDP_logo_tiny.png" alt="CNDP">
  </a>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <div class="navbar-nav mr-auto">
      <a class="nav-link header-link" href="/blog/">Blog</a>
      <a class="nav-link header-link" href="/community/">Community</a>
      <a class="nav-link header-link" href="/dev/">Development</a>
      <a class="nav-link header-link" href="/doc/">Documentation</a>
    </div>
    <div class="navbar-nav ms-auto me-3">
      <a class="nav-link header-link" href="https://github.com/CloudNativeDataPlane/cndp">
        <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
    </div>
  </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CNDP
   &#160;<span id="projectnumber">22.08.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('cthread__api_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cthread_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;<a class="el" href="cne__cycles_8h_source.html">cne_cycles.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="cne__log_8h_source.html">cne_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="cne__branch__prediction_8h_source.html">cne_branch_prediction.h</a>&gt;</code><br />
</div>
<p><a href="cthread__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcthread__semaattr.html">cthread_semaattr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcthread__mutexattr.html">cthread_mutexattr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a33ec398b292bf12c5f9e648ced7a826f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a33ec398b292bf12c5f9e648ced7a826f">MUTEX_RECURSIVE_ATTR</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a33ec398b292bf12c5f9e648ced7a826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10157efb442c554cbc20579f2c8def09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a10157efb442c554cbc20579f2c8def09">CTHREAD_MAX_KEYS</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a10157efb442c554cbc20579f2c8def09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7ac9236412cd6c728bb3ff979fd6de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#adc7ac9236412cd6c728bb3ff979fd6de">CTHREAD_DESTRUCTOR_ITERATIONS</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:adc7ac9236412cd6c728bb3ff979fd6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbae8762f34968f05d4deed14a296ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#abdbae8762f34968f05d4deed14a296ec">CTHREAD_MAX_THREADS</a>&#160;&#160;&#160;CNE_MAX_THREADS</td></tr>
<tr class="separator:abdbae8762f34968f05d4deed14a296ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d4d22b02f91aacea2c471bffc94c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a392d4d22b02f91aacea2c471bffc94c5">CTHREAD_PREALLOC</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a392d4d22b02f91aacea2c471bffc94c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfebac74acfa92f0e463c38bb92deeef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#adfebac74acfa92f0e463c38bb92deeef">CNE_DECLARE_PER_CTHREAD</a>(type,  name)&#160;&#160;&#160;    extern __typeof__(type) __attribute((section(&quot;per_dt&quot;))) per_dt_##name</td></tr>
<tr class="separator:adfebac74acfa92f0e463c38bb92deeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece810b57ba57376764bdea5fafb1341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aece810b57ba57376764bdea5fafb1341">CNE_PER_CTHREAD</a>(name)</td></tr>
<tr class="separator:aece810b57ba57376764bdea5fafb1341"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8bfc8748b31d92fe4b855afaf55d297b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a8bfc8748b31d92fe4b855afaf55d297b">cthread_func_t</a>) (void *)</td></tr>
<tr class="separator:a8bfc8748b31d92fe4b855afaf55d297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460acafbf7a33b06fb4c1dcce9e40c9a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a460acafbf7a33b06fb4c1dcce9e40c9a">tls_destructor_func</a>) (void *)</td></tr>
<tr class="separator:a460acafbf7a33b06fb4c1dcce9e40c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3509ebe16b0777f10c6d2adb2b1d35"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aba3509ebe16b0777f10c6d2adb2b1d35">cthread_cb_t</a>) (struct <a class="el" href="structcthread.html">cthread</a> *c, void *arg, int idx)</td></tr>
<tr class="separator:aba3509ebe16b0777f10c6d2adb2b1d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd0cbbad7cf140e8c34e442f7300e2a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a8cd0cbbad7cf140e8c34e442f7300e2a">sched_cb_t</a>) (struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *s, void *arg, int idx)</td></tr>
<tr class="separator:a8cd0cbbad7cf140e8c34e442f7300e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a866e713d40357a664da92e548e3b61eb"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a866e713d40357a664da92e548e3b61eb">cthread_num_schedulers_set</a> (int num)</td></tr>
<tr class="separator:a866e713d40357a664da92e548e3b61eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3040652f44954a266f156d4d78b45761"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a3040652f44954a266f156d4d78b45761">cthread_active_schedulers</a> (void)</td></tr>
<tr class="separator:a3040652f44954a266f156d4d78b45761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ac9c7edd726907087b2dda6312db14"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a24ac9c7edd726907087b2dda6312db14">cthread_scheduler_shutdown</a> (int thread)</td></tr>
<tr class="separator:a24ac9c7edd726907087b2dda6312db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d05076ca1eb6a30d1051eaee50578d3"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a7d05076ca1eb6a30d1051eaee50578d3">cthread_scheduler_shutdown_all</a> (void)</td></tr>
<tr class="separator:a7d05076ca1eb6a30d1051eaee50578d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3a9393463b575f60ed7b45d1c7f74"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a6cd3a9393463b575f60ed7b45d1c7f74">cthread_run</a> (void)</td></tr>
<tr class="separator:a6cd3a9393463b575f60ed7b45d1c7f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521194bfece818d636f76e4a236908ce"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a521194bfece818d636f76e4a236908ce">cthread_sched_stack_size_set</a> (size_t stack_size)</td></tr>
<tr class="separator:a521194bfece818d636f76e4a236908ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184ef1e6617eef008e59c21310ded0d5"><td class="memItemLeft" align="right" valign="top">CNDP_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a184ef1e6617eef008e59c21310ded0d5">cthread_sched_stack_size</a> (void)</td></tr>
<tr class="separator:a184ef1e6617eef008e59c21310ded0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266990ece40af63920d22831a77bf39"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aa266990ece40af63920d22831a77bf39">cthread_sched_create</a> (size_t stack_size)</td></tr>
<tr class="separator:aa266990ece40af63920d22831a77bf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86495d8e330a9bd939bdcc5854a4793e"><td class="memItemLeft" align="right" valign="top">CNDP_API struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a86495d8e330a9bd939bdcc5854a4793e">cthread_create</a> (const char *name, <a class="el" href="cthread__api_8h.html#a8bfc8748b31d92fe4b855afaf55d297b">cthread_func_t</a> func, void *arg)</td></tr>
<tr class="separator:a86495d8e330a9bd939bdcc5854a4793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02a3cc44851702ff314267ca8e10c05"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ad02a3cc44851702ff314267ca8e10c05">cthread_cancel</a> (struct <a class="el" href="structcthread.html">cthread</a> *ct)</td></tr>
<tr class="separator:ad02a3cc44851702ff314267ca8e10c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e147a6d91866ea71360394007e1b865"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a4e147a6d91866ea71360394007e1b865">cthread_join</a> (struct <a class="el" href="structcthread.html">cthread</a> *ct, void **ptr)</td></tr>
<tr class="separator:a4e147a6d91866ea71360394007e1b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996779a8a68bbb2dfb48d6be7a901d3e"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a996779a8a68bbb2dfb48d6be7a901d3e">cthread_detach</a> (void)</td></tr>
<tr class="separator:a996779a8a68bbb2dfb48d6be7a901d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab6a45ca9ba25789c5b167b2dc5f59"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ae2ab6a45ca9ba25789c5b167b2dc5f59">cthread_exit</a> (void *val)</td></tr>
<tr class="separator:ae2ab6a45ca9ba25789c5b167b2dc5f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7b792bfe99093cade42edeac17b138"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a4c7b792bfe99093cade42edeac17b138">cthread_sleep</a> (uint64_t nsecs)</td></tr>
<tr class="separator:a4c7b792bfe99093cade42edeac17b138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5169ce197489a97227690ab5f876ee"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#afc5169ce197489a97227690ab5f876ee">cthread_sleep_msec</a> (uint64_t ms)</td></tr>
<tr class="separator:afc5169ce197489a97227690ab5f876ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a087c4ff8be2a21340b9303527f5d33"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a4a087c4ff8be2a21340b9303527f5d33">cthread_sleep_clks</a> (uint64_t clks)</td></tr>
<tr class="separator:a4a087c4ff8be2a21340b9303527f5d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1b116325ce6741dbd9d528b54f048b"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a9a1b116325ce6741dbd9d528b54f048b">cthread_sleep_nsecs</a> (uint64_t nsecs)</td></tr>
<tr class="separator:a9a1b116325ce6741dbd9d528b54f048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f97a7e456406a61e29aa6950c1b9f"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a2b4f97a7e456406a61e29aa6950c1b9f">cthread_timer_expired</a> (struct <a class="el" href="structcthread.html">cthread</a> *ct)</td></tr>
<tr class="separator:a2b4f97a7e456406a61e29aa6950c1b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3a2472fac205c923029d1381c621cc"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a7e3a2472fac205c923029d1381c621cc">cthread_yield</a> (void)</td></tr>
<tr class="separator:a7e3a2472fac205c923029d1381c621cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2132fc8678046826c025b230e0953a8"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ab2132fc8678046826c025b230e0953a8">cthread_set_affinity</a> (int thread)</td></tr>
<tr class="separator:ab2132fc8678046826c025b230e0953a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2285be9147c2448973ec7cd2f4606"><td class="memItemLeft" align="right" valign="top">CNDP_API struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a53b2285be9147c2448973ec7cd2f4606">cthread_current</a> (void)</td></tr>
<tr class="separator:a53b2285be9147c2448973ec7cd2f4606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a3248790c66328318dd4fd975205f"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a433a3248790c66328318dd4fd975205f">cthread_set_name</a> (const char *f)</td></tr>
<tr class="separator:a433a3248790c66328318dd4fd975205f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f52f4efa8f1ff006979b7ee0cd71e93"><td class="memItemLeft" align="right" valign="top">CNDP_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a5f52f4efa8f1ff006979b7ee0cd71e93">cthread_get_name</a> (struct <a class="el" href="structcthread.html">cthread</a> *ct)</td></tr>
<tr class="separator:a5f52f4efa8f1ff006979b7ee0cd71e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ffa02e80894d1dc9705e1db6ff6194"><td class="memItemLeft" align="right" valign="top">CNDP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a45ffa02e80894d1dc9705e1db6ff6194">cthread_set_data</a> (void *data)</td></tr>
<tr class="separator:a45ffa02e80894d1dc9705e1db6ff6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37fd27ac5e14d5baf60e18a1116e3d4"><td class="memItemLeft" align="right" valign="top">CNDP_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ae37fd27ac5e14d5baf60e18a1116e3d4">cthread_get_data</a> (void)</td></tr>
<tr class="separator:ae37fd27ac5e14d5baf60e18a1116e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a29c37f15fa14b8ebaf8ff87873da2"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a82a29c37f15fa14b8ebaf8ff87873da2">cthread_key_create</a> (unsigned int *key, <a class="el" href="cthread__api_8h.html#a460acafbf7a33b06fb4c1dcce9e40c9a">tls_destructor_func</a> destructor)</td></tr>
<tr class="separator:a82a29c37f15fa14b8ebaf8ff87873da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678500dff474842ca3b3a890fe2aec8b"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a678500dff474842ca3b3a890fe2aec8b">cthread_key_delete</a> (unsigned int key)</td></tr>
<tr class="separator:a678500dff474842ca3b3a890fe2aec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3db5fec267b7711c5c229ddbc4e527"><td class="memItemLeft" align="right" valign="top">CNDP_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a5a3db5fec267b7711c5c229ddbc4e527">cthread_getspecific</a> (unsigned int key)</td></tr>
<tr class="separator:a5a3db5fec267b7711c5c229ddbc4e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08460e080f8ae27f7ab1fb7cc43694ba"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a08460e080f8ae27f7ab1fb7cc43694ba">cthread_setspecific</a> (unsigned int key, const void *value)</td></tr>
<tr class="separator:a08460e080f8ae27f7ab1fb7cc43694ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26ec342fec4ad985c13a6e5a0695fa8"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ae26ec342fec4ad985c13a6e5a0695fa8">cthread_mutex_init</a> (const char *name, struct cthread_mutex **mutex, const struct <a class="el" href="structcthread__mutexattr.html">cthread_mutexattr</a> *attr)</td></tr>
<tr class="separator:ae26ec342fec4ad985c13a6e5a0695fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bebe8cf2555c2b9d8ae19336ff941"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a216bebe8cf2555c2b9d8ae19336ff941">cthread_mutex_destroy</a> (struct cthread_mutex *mutex)</td></tr>
<tr class="separator:a216bebe8cf2555c2b9d8ae19336ff941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2282be9fe60bd26e3489b0f8f6a890ec"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a2282be9fe60bd26e3489b0f8f6a890ec">cthread_mutex_lock</a> (struct cthread_mutex *mutex)</td></tr>
<tr class="separator:a2282be9fe60bd26e3489b0f8f6a890ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fed2ebf5d66e6b49c8c257187f7ba5e"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a3fed2ebf5d66e6b49c8c257187f7ba5e">cthread_mutex_trylock</a> (struct cthread_mutex *mutex)</td></tr>
<tr class="separator:a3fed2ebf5d66e6b49c8c257187f7ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f7feccbed077f56e9c05e45d6978a0"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a82f7feccbed077f56e9c05e45d6978a0">cthread_mutex_unlock</a> (struct cthread_mutex *mutex)</td></tr>
<tr class="separator:a82f7feccbed077f56e9c05e45d6978a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaac8e2eb8be09e3999cf782402917fc"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#adaac8e2eb8be09e3999cf782402917fc">cthread_mutex_state</a> (struct cthread_mutex *m)</td></tr>
<tr class="separator:adaac8e2eb8be09e3999cf782402917fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb21865ce86098da5fa57d4a3dee52"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a6fbb21865ce86098da5fa57d4a3dee52">cthread_barrier_init</a> (const char *name, struct cthread_barrier **barr, unsigned count)</td></tr>
<tr class="separator:a6fbb21865ce86098da5fa57d4a3dee52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f5b8a418bd5c3098701158ddd6544a"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a11f5b8a418bd5c3098701158ddd6544a">cthread_barrier_destroy</a> (struct cthread_barrier *b)</td></tr>
<tr class="separator:a11f5b8a418bd5c3098701158ddd6544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4b4341c351cccc9b17b91e3781dbe"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a02c4b4341c351cccc9b17b91e3781dbe">cthread_barrier_wait</a> (struct cthread_barrier *b)</td></tr>
<tr class="separator:a02c4b4341c351cccc9b17b91e3781dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122e3362857fbc01cb96205845857dc6"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a122e3362857fbc01cb96205845857dc6">cthread_cond_init</a> (const char *name, struct cthread_cond **c, const struct cthread_condattr *attr)</td></tr>
<tr class="separator:a122e3362857fbc01cb96205845857dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfc0592aaf2fab4846e9854a38fa124"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a5bfc0592aaf2fab4846e9854a38fa124">cthread_cond_destroy</a> (struct cthread_cond *cond)</td></tr>
<tr class="separator:a5bfc0592aaf2fab4846e9854a38fa124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc4fb4947b842a41bfda8e67e4570cf"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aebc4fb4947b842a41bfda8e67e4570cf">cthread_cond_reset</a> (struct cthread_cond *cond)</td></tr>
<tr class="separator:aebc4fb4947b842a41bfda8e67e4570cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae51968a7641a05729190a4dcdf4e7a"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#abae51968a7641a05729190a4dcdf4e7a">cthread_cond_wait</a> (struct cthread_cond *c, struct cthread_mutex *m)</td></tr>
<tr class="separator:abae51968a7641a05729190a4dcdf4e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15fd58e2b968a956d6e9b360517f66c"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ac15fd58e2b968a956d6e9b360517f66c">cthread_cond_timedwait</a> (struct cthread_cond *c, struct cthread_mutex *m, const struct timespec *abstime)</td></tr>
<tr class="separator:ac15fd58e2b968a956d6e9b360517f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69966ec5d03fc7986cca5c9c7f3256c"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#af69966ec5d03fc7986cca5c9c7f3256c">cthread_cond_signal</a> (struct cthread_cond *c)</td></tr>
<tr class="separator:af69966ec5d03fc7986cca5c9c7f3256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f372b1c1f4b3096da53c614369f24c"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ab2f372b1c1f4b3096da53c614369f24c">cthread_cond_broadcast</a> (struct cthread_cond *c)</td></tr>
<tr class="separator:ab2f372b1c1f4b3096da53c614369f24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8302d17f25a94f155e11ee151e0ae60d"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a8302d17f25a94f155e11ee151e0ae60d">cthread_cond_broadcast_no_sched</a> (struct cthread_cond *c)</td></tr>
<tr class="separator:a8302d17f25a94f155e11ee151e0ae60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e9af749c2b5d3c556db0f32ebc65c"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a904e9af749c2b5d3c556db0f32ebc65c">cthread_sema_init</a> (const char *name, struct cthread_sema **s, const struct <a class="el" href="structcthread__semaattr.html">cthread_semaattr</a> *attr)</td></tr>
<tr class="separator:a904e9af749c2b5d3c556db0f32ebc65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd35f32c493755d35c5b0787c3a4ed5"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a8fd35f32c493755d35c5b0787c3a4ed5">cthread_sema_destroy</a> (struct cthread_sema *sema)</td></tr>
<tr class="separator:a8fd35f32c493755d35c5b0787c3a4ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0faebce635a9a07adf25ec0e07cc1d"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aae0faebce635a9a07adf25ec0e07cc1d">cthread_sema_reset</a> (struct cthread_sema *sema)</td></tr>
<tr class="separator:aae0faebce635a9a07adf25ec0e07cc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2c84ba7fd6a0b70f939becf7aaef4"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a2fb2c84ba7fd6a0b70f939becf7aaef4">cthread_sema_wait</a> (struct cthread_sema *s, struct cthread_mutex *m)</td></tr>
<tr class="separator:a2fb2c84ba7fd6a0b70f939becf7aaef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec89856a82e7ec497e37c4392e41031"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a3ec89856a82e7ec497e37c4392e41031">cthread_sema_timedwait</a> (struct cthread_sema *s, struct cthread_mutex *m, const struct timespec *abstime)</td></tr>
<tr class="separator:a3ec89856a82e7ec497e37c4392e41031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa308ecc946548cb0a1f75cc6a0d607c8"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aa308ecc946548cb0a1f75cc6a0d607c8">cthread_sema_signal</a> (struct cthread_sema *s)</td></tr>
<tr class="separator:aa308ecc946548cb0a1f75cc6a0d607c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d9cacfdd50008c550b362e8c82c70"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#afd5d9cacfdd50008c550b362e8c82c70">cthread_sema_flush</a> (struct cthread_sema *s)</td></tr>
<tr class="separator:afd5d9cacfdd50008c550b362e8c82c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e5c37077435719a6e7860eb08f454"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a5b3e5c37077435719a6e7860eb08f454">cthread_sema_flush_no_sched</a> (struct cthread_sema *s)</td></tr>
<tr class="separator:a5b3e5c37077435719a6e7860eb08f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043b6df21e1c6c04c7e2b8b38ba85ff2"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a043b6df21e1c6c04c7e2b8b38ba85ff2">is_cthread_running</a> (void)</td></tr>
<tr class="separator:a043b6df21e1c6c04c7e2b8b38ba85ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a87c6859aa105f94f202fa955286999"><td class="memItemLeft" align="right" valign="top">CNDP_API struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a0a87c6859aa105f94f202fa955286999">cthread_find</a> (struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *s, int threadid)</td></tr>
<tr class="separator:a0a87c6859aa105f94f202fa955286999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae03992684d8b8d3cc3944bf515d0a6"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a2ae03992684d8b8d3cc3944bf515d0a6">cthread_foreach</a> (struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *s, <a class="el" href="cthread__api_8h.html#aba3509ebe16b0777f10c6d2adb2b1d35">cthread_cb_t</a> func, void *arg)</td></tr>
<tr class="separator:a2ae03992684d8b8d3cc3944bf515d0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ae871ba888d6d9be59ed10f0569fb1"><td class="memItemLeft" align="right" valign="top">CNDP_API struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a15ae871ba888d6d9be59ed10f0569fb1">cthread_get_sched</a> (struct <a class="el" href="structcthread.html">cthread</a> *c)</td></tr>
<tr class="separator:a15ae871ba888d6d9be59ed10f0569fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49057fbd1754fd674ff537b05541435f"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a49057fbd1754fd674ff537b05541435f">cthread_sched_id</a> (struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *s)</td></tr>
<tr class="separator:a49057fbd1754fd674ff537b05541435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba1580bb64195ad56d2df039197f2f8"><td class="memItemLeft" align="right" valign="top">CNDP_API struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a1ba1580bb64195ad56d2df039197f2f8">cthread_sched_find</a> (int schedid)</td></tr>
<tr class="separator:a1ba1580bb64195ad56d2df039197f2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d608077a198d3422d6f0a49222394f2"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a1d608077a198d3422d6f0a49222394f2">cthread_sched_foreach</a> (<a class="el" href="cthread__api_8h.html#a8cd0cbbad7cf140e8c34e442f7300e2a">sched_cb_t</a> func, void *arg)</td></tr>
<tr class="separator:a1d608077a198d3422d6f0a49222394f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd05e5d2c84ce9bd1982d5238044bf3"><td class="memItemLeft" align="right" valign="top">CNDP_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#adcd05e5d2c84ce9bd1982d5238044bf3">cthread_thread_private</a> (struct <a class="el" href="structcthread.html">cthread</a> *c)</td></tr>
<tr class="separator:adcd05e5d2c84ce9bd1982d5238044bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cf67ee5ec1549a043f80522275deac"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ab0cf67ee5ec1549a043f80522275deac">cthread_set_thread_private</a> (struct <a class="el" href="structcthread.html">cthread</a> *c, void *arg)</td></tr>
<tr class="separator:ab0cf67ee5ec1549a043f80522275deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe917442e03aef51d4c149eb50af2736"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#abe917442e03aef51d4c149eb50af2736">cthread_once_init</a> (struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> **once)</td></tr>
<tr class="separator:abe917442e03aef51d4c149eb50af2736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90ad8624a848a3c754f0deeead50064"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ab90ad8624a848a3c754f0deeead50064">cthread_once_destroy</a> (struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> *once)</td></tr>
<tr class="separator:ab90ad8624a848a3c754f0deeead50064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2570dbb8124eb0d83bbace7bd52e9f1"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#ac2570dbb8124eb0d83bbace7bd52e9f1">cthread_once_reset</a> (struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> *once)</td></tr>
<tr class="separator:ac2570dbb8124eb0d83bbace7bd52e9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c895145d7097ee824e420f4198b221"><td class="memItemLeft" align="right" valign="top">CNDP_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> (struct cthread_once *once, int(*func)(void *), void *arg)</td></tr>
<tr class="separator:a38c895145d7097ee824e420f4198b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aadf9fabf6ed7901ff33ecc4eea76ee64"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cthread__api_8h.html#aadf9fabf6ed7901ff33ecc4eea76ee64">__start_per_dt</a></td></tr>
<tr class="separator:aadf9fabf6ed7901ff33ecc4eea76ee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the public API for the D-thread subsystem</p>
<p>The L_thread subsystem provides a simple cooperative scheduler to enable arbitrary functions to run as cooperative threads within a single P-thread.</p>
<p>The subsystem provides a P-thread like API that is intended to assist in reuse of legacy code written for POSIX p_threads.</p>
<p>The D-thread subsystem relies on cooperative multitasking, as such an D-thread must possess frequent rescheduling points. Often these rescheduling points are provided transparently when the application invokes an D-thread API.</p>
<p>In some applications it is possible that the program may enter a loop the exit condition for which depends on the action of another thread or a response from hardware. In such a case it is necessary to yield the thread periodically in the loop body, to allow other threads an opportunity to run. This can be done by inserting a call to <a class="el" href="cthread__api_8h.html#a7e3a2472fac205c923029d1381c621cc">cthread_yield()</a> or cthread_sleep(n) in the body of the loop.</p>
<p>If the application makes expensive / blocking system calls or does other work that would take an inordinate amount of time to complete, this will stall the cooperative scheduler resulting in very poor performance.</p>
<p>In such cases an D-thread can be migrated temporarily to another scheduler running in a different P-thread on another core. When the expensive or blocking operation is completed it can be migrated back to the original scheduler. In this way other threads can continue to run on the original scheduler and will be completely unaffected by the blocking behaviour. To migrate an D-thread to another scheduler the API <a class="el" href="cthread__api_8h.html#ab2132fc8678046826c025b230e0953a8">cthread_set_affinity()</a> is provided.</p>
<p>If D-threads that share data are running on the same core it is possible to design programs where mutual exclusion mechanisms to protect shared data can be avoided. This is due to the fact that the cooperative threads cannot preempt each other.</p>
<p>There are two cases where mutual exclusion mechanisms are necessary.</p>
<p>a) Where the D-threads sharing data are running on different cores. b) Where code must yield while updating data shared with another thread.</p>
<p>The D-thread subsystem provides a set of mutex APIs to help with such scenarios, however excessive reliance on on these will impact performance and is best avoided if possible.</p>
<p>D-threads can synchronise using a fast condition variable implementation that supports signal and broadcast. An D-thread running on any core can wait on a condition.</p>
<p>D-threads can have D-thread local storage with an API modelled on either the P-thread get/set specific API or using PER_CTHREAD macros modelled on the CNE_PER_THREAD macros. Alternatively a simple user data pointer may be set and retrieved from a thread. </p>

<p class="definition">Definition in file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a33ec398b292bf12c5f9e648ced7a826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ec398b292bf12c5f9e648ced7a826f">&#9670;&nbsp;</a></span>MUTEX_RECURSIVE_ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_RECURSIVE_ATTR&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutex recursive flag </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00130">130</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="a10157efb442c554cbc20579f2c8def09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10157efb442c554cbc20579f2c8def09">&#9670;&nbsp;</a></span>CTHREAD_MAX_KEYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CTHREAD_MAX_KEYS&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the maximum number of TLS keys that can be created </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00148">148</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="adc7ac9236412cd6c728bb3ff979fd6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7ac9236412cd6c728bb3ff979fd6de">&#9670;&nbsp;</a></span>CTHREAD_DESTRUCTOR_ITERATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CTHREAD_DESTRUCTOR_ITERATIONS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the maximum number of attempts to destroy an cthread's TLS data on thread exit </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00154">154</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="abdbae8762f34968f05d4deed14a296ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbae8762f34968f05d4deed14a296ec">&#9670;&nbsp;</a></span>CTHREAD_MAX_THREADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CTHREAD_MAX_THREADS&#160;&#160;&#160;CNE_MAX_THREADS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the maximum number of threads that will support cthreads </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00159">159</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="a392d4d22b02f91aacea2c471bffc94c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392d4d22b02f91aacea2c471bffc94c5">&#9670;&nbsp;</a></span>CTHREAD_PREALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CTHREAD_PREALLOC&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many cthread objects to pre-allocate as the system grows applies to cthreads + stacks, TLS, mutexes, cond vars.</p>
<dl class="section see"><dt>See also</dt><dd>_cthread_alloc() </dd>
<dd>
_cond_alloc() </dd>
<dd>
_sema_alloc() </dd>
<dd>
_mutex_alloc() </dd></dl>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00171">171</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="adfebac74acfa92f0e463c38bb92deeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfebac74acfa92f0e463c38bb92deeef">&#9670;&nbsp;</a></span>CNE_DECLARE_PER_CTHREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CNE_DECLARE_PER_CTHREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    extern __typeof__(type) __attribute((section(&quot;per_dt&quot;))) per_dt_##name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to declare an er cthread variable "var" of type "type" </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00665">665</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="aece810b57ba57376764bdea5fafb1341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece810b57ba57376764bdea5fafb1341">&#9670;&nbsp;</a></span>CNE_PER_CTHREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CNE_PER_CTHREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((typeof(per_dt_##name) *)((<span class="keywordtype">char</span> *)<a class="code" href="cthread__api_8h.html#ae37fd27ac5e14d5baf60e18a1116e3d4">cthread_get_data</a>() + \</div>
<div class="line">                               ((<span class="keywordtype">char</span> *)&amp;per_dt_##name - &amp;<a class="code" href="cthread__api_8h.html#aadf9fabf6ed7901ff33ecc4eea76ee64">__start_per_dt</a>)))</div>
<div class="ttc" id="acthread__api_8h_html_aadf9fabf6ed7901ff33ecc4eea76ee64"><div class="ttname"><a href="cthread__api_8h.html#aadf9fabf6ed7901ff33ecc4eea76ee64">__start_per_dt</a></div><div class="ttdeci">char __start_per_dt</div></div>
<div class="ttc" id="acthread__api_8h_html_ae37fd27ac5e14d5baf60e18a1116e3d4"><div class="ttname"><a href="cthread__api_8h.html#ae37fd27ac5e14d5baf60e18a1116e3d4">cthread_get_data</a></div><div class="ttdeci">CNDP_API void * cthread_get_data(void)</div></div>
</div><!-- fragment --><p>Read/write the per-thread variable value </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00670">670</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8bfc8748b31d92fe4b855afaf55d297b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfc8748b31d92fe4b855afaf55d297b">&#9670;&nbsp;</a></span>cthread_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cthread_func_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for any cthread function called from <a class="el" href="cthread__api_8h.html#a86495d8e330a9bd939bdcc5854a4793e">cthread_create()</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a15">examples/phil/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00135">135</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="a460acafbf7a33b06fb4c1dcce9e40c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460acafbf7a33b06fb4c1dcce9e40c9a">&#9670;&nbsp;</a></span>tls_destructor_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tls_destructor_func) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor function pointer </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l00522">522</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="aba3509ebe16b0777f10c6d2adb2b1d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3509ebe16b0777f10c6d2adb2b1d35">&#9670;&nbsp;</a></span>cthread_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* cthread_cb_t) (struct <a class="el" href="structcthread.html">cthread</a> *c, void *arg, int idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cthread callback function pointer for the foreach type APIs </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l01128">1128</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<a id="a8cd0cbbad7cf140e8c34e442f7300e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd0cbbad7cf140e8c34e442f7300e2a">&#9670;&nbsp;</a></span>sched_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sched_cb_t) (struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *s, void *arg, int idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The callback for the <a class="el" href="cthread__api_8h.html#a1d608077a198d3422d6f0a49222394f2">cthread_sched_foreach()</a> callback. </p>

<p class="definition">Definition at line <a class="el" href="cthread__api_8h_source.html#l01169">1169</a> of file <a class="el" href="cthread__api_8h_source.html">cthread_api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a866e713d40357a664da92e548e3b61eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e713d40357a664da92e548e3b61eb">&#9670;&nbsp;</a></span>cthread_num_schedulers_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_num_schedulers_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of schedulers in the system.</p>
<p>This function may optionally be called before starting schedulers.</p>
<p>If the number of schedulers is not set, or set to 0 then each scheduler will begin scheduling cthreads immediately when it is started.</p>
<p>If the number of schedulers is set to greater than 0, then each scheduler will wait until all schedulers have started before beginning to schedule cthreads.</p>
<p>If an application wishes to have threads migrate between cores using <a class="el" href="cthread__api_8h.html#ab2132fc8678046826c025b230e0953a8">cthread_set_affinity()</a>, or join threads running on other cores using <a class="el" href="cthread__api_8h.html#a4e147a6d91866ea71360394007e1b865">cthread_join()</a>, then it is prudent to set the number of schedulers to ensure that all schedulers are initialised beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>the number of schedulers in the system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of schedulers in the system </dd></dl>

</div>
</div>
<a id="a3040652f44954a266f156d4d78b45761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3040652f44954a266f156d4d78b45761">&#9670;&nbsp;</a></span>cthread_active_schedulers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_active_schedulers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of schedulers currently running </p><dl class="section return"><dt>Returns</dt><dd>the number of schedulers in the system </dd></dl>

</div>
</div>
<a id="a24ac9c7edd726907087b2dda6312db14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ac9c7edd726907087b2dda6312db14">&#9670;&nbsp;</a></span>cthread_scheduler_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_scheduler_shutdown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown the specified scheduler</p>
<p>This function tells the specified scheduler to exit if/when there is no more work to do.</p>
<p>Note that although the scheduler will stop resources are not freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread of the scheduler to shutdown</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a7d05076ca1eb6a30d1051eaee50578d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d05076ca1eb6a30d1051eaee50578d3">&#9670;&nbsp;</a></span>cthread_scheduler_shutdown_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_scheduler_shutdown_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown all schedulers</p>
<p>This function tells all schedulers including the current scheduler to exit if/when there is no more work to do.</p>
<p>Note that although the schedulers will stop resources are not freed.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a6cd3a9393463b575f60ed7b45d1c7f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd3a9393463b575f60ed7b45d1c7f74">&#9670;&nbsp;</a></span>cthread_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the cthread scheduler</p>
<p>Runs the cthread scheduler. This function returns only if/when all cthreads have exited. This function must be the main loop of an CNE thread.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a17">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a521194bfece818d636f76e4a236908ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521194bfece818d636f76e4a236908ce">&#9670;&nbsp;</a></span>cthread_sched_stack_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_sched_stack_size_set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the scheduler stack size all threads on the scheduler.</p>
<p>Must be called before the scheduler is started and will become the default stack size for all schedulers created after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_size</td><td>Size in bytes of the scheduler stack, can be zero to use the default size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184ef1e6617eef008e59c21310ded0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184ef1e6617eef008e59c21310ded0d5">&#9670;&nbsp;</a></span>cthread_sched_stack_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API size_t cthread_sched_stack_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the scheduler default stack size.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of default bytes in a scheduler stack. </dd></dl>

</div>
</div>
<a id="aa266990ece40af63920d22831a77bf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa266990ece40af63920d22831a77bf39">&#9670;&nbsp;</a></span>cthread_sched_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sched_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a scehduler on the current thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_size</td><td>The number of bytes to allocate for a stack for all threads in a scheduler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scheduler ID value or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a13">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a86495d8e330a9bd939bdcc5854a4793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86495d8e330a9bd939bdcc5854a4793e">&#9670;&nbsp;</a></span>cthread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API struct <a class="el" href="structcthread.html">cthread</a>* cthread_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cthread__api_8h.html#a8bfc8748b31d92fe4b855afaf55d297b">cthread_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an cthread</p>
<p>Creates an cthread and places it in the ready queue on a particular thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the thread to be created, can be NULL </td></tr>
    <tr><td class="paramname">func</td><td>Pointer to the function the for the thread to run </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer to args that will be passed to the thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EAGAIN no resources available EINVAL NULL thread or function pointer </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a14">examples/phil/main.c</a>, and <a class="el" href="examples_2phil_2phil_8c-example.html#a12">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad02a3cc44851702ff314267ca8e10c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02a3cc44851702ff314267ca8e10c05">&#9670;&nbsp;</a></span>cthread_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel an cthread</p>
<p>Cancels an cthread and causes it to be terminated If the cthread is detached it will be freed immediately otherwise its resources will not be released until it is joined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>Pointer to an cthread that will be cancelled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL thread was NULL </dd></dl>

</div>
</div>
<a id="a4e147a6d91866ea71360394007e1b865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e147a6d91866ea71360394007e1b865">&#9670;&nbsp;</a></span>cthread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_join </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join an cthread</p>
<p>Joins the current thread with the specified cthread, and waits for that thread to exit. Passes an optional pointer to collect returned data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>Pointer to the cthread to be joined </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to pointer to collect returned data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL cthread could not be joined. </dd></dl>

</div>
</div>
<a id="a996779a8a68bbb2dfb48d6be7a901d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996779a8a68bbb2dfb48d6be7a901d3e">&#9670;&nbsp;</a></span>cthread_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach an cthread</p>
<p>Detaches the current thread On exit a detached cthread will be freed immediately and will not wait to be joined. The default state for a thread is not detached.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ae2ab6a45ca9ba25789c5b167b2dc5f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ab6a45ca9ba25789c5b167b2dc5f59">&#9670;&nbsp;</a></span>cthread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit an cthread</p>
<p>Terminate the current thread, optionally return data. The data may be collected by <a class="el" href="cthread__api_8h.html#a4e147a6d91866ea71360394007e1b865">cthread_join()</a></p>
<p>After calling this function the cthread will be suspended until it is joined. After it is joined then its resources will be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to pointer to data to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a4c7b792bfe99093cade42edeac17b138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7b792bfe99093cade42edeac17b138">&#9670;&nbsp;</a></span>cthread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_sleep </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nsecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current cthread to sleep for n nanoseconds</p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next cthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsecs</td><td>Number of nanoseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="afc5169ce197489a97227690ab5f876ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5169ce197489a97227690ab5f876ee">&#9670;&nbsp;</a></span>cthread_sleep_msec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_sleep_msec </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current cthread to sleep for n milliseconds</p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next cthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Number of milliseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a8">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a4a087c4ff8be2a21340b9303527f5d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a087c4ff8be2a21340b9303527f5d33">&#9670;&nbsp;</a></span>cthread_sleep_clks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_sleep_clks </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>clks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current cthread to sleep for n cpu clock ticks</p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next cthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clks</td><td>Number of clock ticks to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a9a1b116325ce6741dbd9d528b54f048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1b116325ce6741dbd9d528b54f048b">&#9670;&nbsp;</a></span>cthread_sleep_nsecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_sleep_nsecs </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nsecs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current cthread to sleep for n nsecs</p>
<p>The current thread will be suspended until the specified time has elapsed or has been exceeded.</p>
<p>Execution will switch to the next cthread that is ready to run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsecs</td><td>Number of nsecs to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a2b4f97a7e456406a61e29aa6950c1b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4f97a7e456406a61e29aa6950c1b9f">&#9670;&nbsp;</a></span>cthread_timer_expired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_timer_expired </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the state of the expired flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>If <code>ct</code> is null then use THIS_CTHREAD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ct has expired a timer </dd></dl>

</div>
</div>
<a id="a7e3a2472fac205c923029d1381c621cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3a2472fac205c923029d1381c621cc">&#9670;&nbsp;</a></span>cthread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield the current cthread</p>
<p>The current thread will yield and execution will switch to the next cthread that is ready to run</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ab2132fc8678046826c025b230e0953a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2132fc8678046826c025b230e0953a8">&#9670;&nbsp;</a></span>cthread_set_affinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_set_affinity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Migrate the current thread to another scheduler</p>
<p>This function migrates the current thread to another scheduler. Execution will switch to the next cthread that is ready to run on the current scheduler. The current thread will be resumed on the new scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to migrate to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success we are now running on the specified core EINVAL the destination thread was not valid </dd></dl>

</div>
</div>
<a id="a53b2285be9147c2448973ec7cd2f4606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2285be9147c2448973ec7cd2f4606">&#9670;&nbsp;</a></span>cthread_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API struct <a class="el" href="structcthread.html">cthread</a>* cthread_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the current cthread</p>
<p>Returns the current cthread</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current cthread </dd></dl>

</div>
</div>
<a id="a433a3248790c66328318dd4fd975205f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433a3248790c66328318dd4fd975205f">&#9670;&nbsp;</a></span>cthread_set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_set_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current thread name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The name of the thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f52f4efa8f1ff006979b7ee0cd71e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f52f4efa8f1ff006979b7ee0cd71e93">&#9670;&nbsp;</a></span>cthread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API const char* cthread_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the thread name string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>The cthread pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string pointer the name of thread or NULL on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a5">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a45ffa02e80894d1dc9705e1db6ff6194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ffa02e80894d1dc9705e1db6ff6194">&#9670;&nbsp;</a></span>cthread_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void cthread_set_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associate user data with an cthread</p>
<p>This function sets a user data pointer in the current cthread The pointer can be retrieved with <a class="el" href="cthread__api_8h.html#ae37fd27ac5e14d5baf60e18a1116e3d4">cthread_get_data()</a> It is the users responsibility to allocate and free any data referenced by the user pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ae37fd27ac5e14d5baf60e18a1116e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37fd27ac5e14d5baf60e18a1116e3d4">&#9670;&nbsp;</a></span>cthread_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void* cthread_get_data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get user data for the current cthread</p>
<p>This function returns a user data pointer for the current cthread The pointer must first be set with <a class="el" href="cthread__api_8h.html#a45ffa02e80894d1dc9705e1db6ff6194">cthread_set_data()</a> It is the users responsibility to allocate and free any data referenced by the user pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to user data </dd></dl>

</div>
</div>
<a id="a82a29c37f15fa14b8ebaf8ff87873da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a29c37f15fa14b8ebaf8ff87873da2">&#9670;&nbsp;</a></span>cthread_key_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_key_create </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cthread__api_8h.html#a460acafbf7a33b06fb4c1dcce9e40c9a">tls_destructor_func</a>&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a key for cthread TLS</p>
<p>This function is modelled on pthread_key_create It creates a thread-specific data key visible to all cthreads on the current scheduler.</p>
<p>Key values may be used to locate thread-specific data. The same key value may be used by different threads, the values bound to the key by <a class="el" href="cthread__api_8h.html#a08460e080f8ae27f7ab1fb7cc43694ba">cthread_setspecific()</a> are maintained on a per-thread basis and persist for the life of the calling thread.</p>
<p>An optional destructor function may be associated with each key value. At thread exit, if a key value has a non-NULL destructor pointer, and the thread has a non-NULL value associated with the key, the function pointed to is called with the current associated value as its sole argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to the key to be created </td></tr>
    <tr><td class="paramname">destructor</td><td>Pointer to destructor function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL the key ptr was NULL EAGAIN no resources available </dd></dl>

</div>
</div>
<a id="a678500dff474842ca3b3a890fe2aec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678500dff474842ca3b3a890fe2aec8b">&#9670;&nbsp;</a></span>cthread_key_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_key_delete </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete key for cthread TLS</p>
<p>This function is modelled on pthread_key_delete(). It deletes a thread-specific data key previously returned by <a class="el" href="cthread__api_8h.html#a82a29c37f15fa14b8ebaf8ff87873da2">cthread_key_create()</a>. The thread-specific data values associated with the key need not be NULL at the time that cthread_key_delete is called. It is the responsibility of the application to free any application storage or perform any cleanup actions for data structures related to the deleted key. This cleanup can be done either before or after cthread_key_delete is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL the key was invalid </dd></dl>

</div>
</div>
<a id="a5a3db5fec267b7711c5c229ddbc4e527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3db5fec267b7711c5c229ddbc4e527">&#9670;&nbsp;</a></span>cthread_getspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void* cthread_getspecific </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get cthread TLS</p>
<p>This function is modelled on pthread_get_specific(). It returns the value currently bound to the specified key on behalf of the calling thread. Calling <a class="el" href="cthread__api_8h.html#a5a3db5fec267b7711c5c229ddbc4e527">cthread_getspecific()</a> with a key value not obtained from <a class="el" href="cthread__api_8h.html#a82a29c37f15fa14b8ebaf8ff87873da2">cthread_key_create()</a> or after key has been deleted with <a class="el" href="cthread__api_8h.html#a678500dff474842ca3b3a890fe2aec8b">cthread_key_delete()</a> will result in undefined behaviour. <a class="el" href="cthread__api_8h.html#a5a3db5fec267b7711c5c229ddbc4e527">cthread_getspecific()</a> may be called from a thread-specific data destructor function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for which data is requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the thread specific data associated with that key or NULL if no data has been set. </dd></dl>

</div>
</div>
<a id="a08460e080f8ae27f7ab1fb7cc43694ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08460e080f8ae27f7ab1fb7cc43694ba">&#9670;&nbsp;</a></span>cthread_setspecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_setspecific </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set cthread TLS</p>
<p>This function is modelled on pthread_set_specific() It associates a thread-specific value with a key obtained via a previous call to <a class="el" href="cthread__api_8h.html#a82a29c37f15fa14b8ebaf8ff87873da2">cthread_key_create()</a>. Different threads may bind different values to the same key. These values are typically pointers to dynamically allocated memory that have been reserved by the calling thread. Calling cthread_setspecific with a key value not obtained from cthread_key_create or after the key has been deleted with cthread_key_delete will result in undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for which data is to be set </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL the key was invalid </dd></dl>

</div>
</div>
<a id="ae26ec342fec4ad985c13a6e5a0695fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26ec342fec4ad985c13a6e5a0695fa8">&#9670;&nbsp;</a></span>cthread_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_mutex **&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcthread__mutexattr.html">cthread_mutexattr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a mutex</p>
<p>This function provides a mutual exclusion device, the need for which can normally be avoided in a cooperative multitasking environment. It is provided to aid porting of legacy code originally written for preemptive multitasking environments such as pthreads.</p>
<p>A mutex may be unlocked (not owned by any thread), or locked (owned by one thread).</p>
<p>A mutex can never be owned by more than one thread simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex.</p>
<p><a class="el" href="cthread__api_8h.html#ae26ec342fec4ad985c13a6e5a0695fa8">cthread_mutex_init()</a> initializes the mutex object pointed to by mutex Optional mutex attributes specified in mutexattr, are reserved for future use and are currently ignored.</p>
<p>If a thread calls <a class="el" href="cthread__api_8h.html#a2282be9fe60bd26e3489b0f8f6a890ec">cthread_mutex_lock()</a> on the mutex, then if the mutex is currently unlocked, it becomes locked and owned by the calling thread, and cthread_mutex_lock returns immediately. If the mutex is already locked by another thread, cthread_mutex_lock suspends the calling thread until the mutex is unlocked.</p>
<p>cthread_mutex_trylock behaves identically to cthread_mutex_lock, except that it does not block the calling thread if the mutex is already locked by another thread.</p>
<p><a class="el" href="cthread__api_8h.html#a82f7feccbed077f56e9c05e45d6978a0">cthread_mutex_unlock()</a> unlocks the specified mutex. The mutex is assumed to be locked and owned by the calling thread.</p>
<p><a class="el" href="cthread__api_8h.html#a216bebe8cf2555c2b9d8ae19336ff941">cthread_mutex_destroy()</a> destroys a mutex object, freeing its resources. The mutex must be unlocked with nothing blocked on it before calling cthread_mutex_destroy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Optional pointer to string describing the mutex </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized </td></tr>
    <tr><td class="paramname">attr</td><td>Pointer to attribute - unused reserved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not a valid pointer EAGAIN insufficient resources </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a9">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a216bebe8cf2555c2b9d8ae19336ff941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216bebe8cf2555c2b9d8ae19336ff941">&#9670;&nbsp;</a></span>cthread_mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a mutex</p>
<p>This function destroys the specified mutex freeing its resources. The mutex must be unlocked before calling cthread_mutex_destroy.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cthread__api_8h.html#ae26ec342fec4ad985c13a6e5a0695fa8">cthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EBUSY mutex was still in use </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a14">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2282be9fe60bd26e3489b0f8f6a890ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2282be9fe60bd26e3489b0f8f6a890ec">&#9670;&nbsp;</a></span>cthread_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock a mutex</p>
<p>This function attempts to lock a mutex. If a thread calls <a class="el" href="cthread__api_8h.html#a2282be9fe60bd26e3489b0f8f6a890ec">cthread_mutex_lock()</a> on the mutex, then if the mutex is currently unlocked, it becomes locked and owned by the calling thread, and cthread_mutex_lock returns immediately. If the mutex is already locked by another thread, cthread_mutex_lock suspends the calling thread until the mutex is unlocked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cthread__api_8h.html#ae26ec342fec4ad985c13a6e5a0695fa8">cthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EDEADLOCK the mutex was already owned by the calling thread </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a2">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a3fed2ebf5d66e6b49c8c257187f7ba5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fed2ebf5d66e6b49c8c257187f7ba5e">&#9670;&nbsp;</a></span>cthread_mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to lock a mutex</p>
<p>This function attempts to lock a mutex. cthread_mutex_trylock behaves identically to cthread_mutex_lock, except that it does not block the calling thread if the mutex is already locked by another thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cthread__api_8h.html#ae26ec342fec4ad985c13a6e5a0695fa8">cthread_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL mutex was not an initialized mutex EBUSY the mutex was already locked by another thread </dd></dl>

</div>
</div>
<a id="a82f7feccbed077f56e9c05e45d6978a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f7feccbed077f56e9c05e45d6978a0">&#9670;&nbsp;</a></span>cthread_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock a mutex</p>
<p>This function attempts to unlock the specified mutex. The mutex is assumed to be locked and owned by the calling thread.</p>
<p>The oldest of any threads blocked on the mutex is made ready and may compete with any other running thread to gain the mutex, it fails it will be blocked again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to pointer to the mutex to be initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 mutex was unlocked EINVAL mutex was not an initialized mutex EPERM the mutex was not owned by the calling thread </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a3">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="adaac8e2eb8be09e3999cf782402917fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaac8e2eb8be09e3999cf782402917fc">&#9670;&nbsp;</a></span>cthread_mutex_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_mutex_state </td>
          <td>(</td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mutex state value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state value </dd></dl>

</div>
</div>
<a id="a6fbb21865ce86098da5fa57d4a3dee52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbb21865ce86098da5fa57d4a3dee52">&#9670;&nbsp;</a></span>cthread_barrier_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_barrier_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_barrier **&#160;</td>
          <td class="paramname"><em>barr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a barrier structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the barrier </td></tr>
    <tr><td class="paramname">barr</td><td>Pointer to a pointer of the cthread_barrier structure </td></tr>
    <tr><td class="paramname">count</td><td>The number of times <a class="el" href="cthread__api_8h.html#a02c4b4341c351cccc9b17b91e3781dbe">cthread_barrier_wait()</a> needs to be called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a10">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a11f5b8a418bd5c3098701158ddd6544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f5b8a418bd5c3098701158ddd6544a">&#9670;&nbsp;</a></span>cthread_barrier_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_barrier_destroy </td>
          <td>(</td>
          <td class="paramtype">struct cthread_barrier *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a barrier structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The cthread_barrier pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a13">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a02c4b4341c351cccc9b17b91e3781dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c4b4341c351cccc9b17b91e3781dbe">&#9670;&nbsp;</a></span>cthread_barrier_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_barrier_wait </td>
          <td>(</td>
          <td class="paramtype">struct cthread_barrier *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on a barrier counter to be decremented to zero before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The barrier pointer to wait on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a7">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="a122e3362857fbc01cb96205845857dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122e3362857fbc01cb96205845857dc6">&#9670;&nbsp;</a></span>cthread_cond_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_cond **&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct cthread_condattr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a condition variable</p>
<p>This function initializes a condition variable.</p>
<p>Condition variables can be used to communicate changes in the state of data shared between threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cthread__api_8h.html#abae51968a7641a05729190a4dcdf4e7a">cthread_cond_wait()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to optional string describing the condition variable </td></tr>
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be initialized </td></tr>
    <tr><td class="paramname">attr</td><td>Pointer to optional attribute reserved for future use, currently ignored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL cond was not a valid pointer EAGAIN insufficient resources </dd></dl>

</div>
</div>
<a id="a5bfc0592aaf2fab4846e9854a38fa124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfc0592aaf2fab4846e9854a38fa124">&#9670;&nbsp;</a></span>cthread_cond_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_destroy </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a condition variable</p>
<p>This function destroys a condition variable that was created with <a class="el" href="cthread__api_8h.html#a122e3362857fbc01cb96205845857dc6">cthread_cond_init()</a> and releases its resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be destroyed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EBUSY condition variable was still in use EINVAL was not an initialised condition variable </dd></dl>

</div>
</div>
<a id="aebc4fb4947b842a41bfda8e67e4570cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc4fb4947b842a41bfda8e67e4570cf">&#9670;&nbsp;</a></span>cthread_cond_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_reset </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a condition variable to initialized state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to pointer to the condition variable to be destroyed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EBUSY condition variable was still in use EINVAL was not an initialised condition variable </dd></dl>

</div>
</div>
<a id="abae51968a7641a05729190a4dcdf4e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae51968a7641a05729190a4dcdf4e7a">&#9670;&nbsp;</a></span>cthread_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_wait </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on a condition variable</p>
<p>The function blocks the current thread waiting on the condition variable specified by cond. The waiting thread unblocks only after another thread calls cthread_cond_signal, or cthread_cond_broadcast, specifying the same condition variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be waited on</td></tr>
    <tr><td class="paramname">m</td><td>Mutex to release or NULL if no mutex. (Currently not supported)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="ac15fd58e2b968a956d6e9b360517f66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15fd58e2b968a956d6e9b360517f66c">&#9670;&nbsp;</a></span>cthread_cond_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_timedwait </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on a condition variable with timeout</p>
<p>The function blocks the current thread waiting on the condition variable specified by cond. The waiting thread unblocks only after another thread calls cthread_cond_signal, or cthread_cond_broadcast, specifying the same condition variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be waited on</td></tr>
    <tr><td class="paramname">m</td><td>Mutex to release or NULL if no mutex. (Currently not supported)</td></tr>
    <tr><td class="paramname">abstime</td><td>Timespec used for timeout value. (Currently not supported)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="af69966ec5d03fc7986cca5c9c7f3256c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69966ec5d03fc7986cca5c9c7f3256c">&#9670;&nbsp;</a></span>cthread_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_signal </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal a condition variable</p>
<p>The function unblocks one thread waiting for the condition variable cond. If no threads are waiting on cond, the <a class="el" href="cthread__api_8h.html#af69966ec5d03fc7986cca5c9c7f3256c">cthread_cond_signal()</a> function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be signalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="ab2f372b1c1f4b3096da53c614369f24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f372b1c1f4b3096da53c614369f24c">&#9670;&nbsp;</a></span>cthread_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Broadcast a condition variable</p>
<p>The function unblocks all threads waiting for the condition variable cond. If no threads are waiting on cond, the <a class="el" href="cthread__api_8h.html#ab2f372b1c1f4b3096da53c614369f24c">cthread_cond_broadcast()</a> function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be signalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="a8302d17f25a94f155e11ee151e0ae60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8302d17f25a94f155e11ee151e0ae60d">&#9670;&nbsp;</a></span>cthread_cond_broadcast_no_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_cond_broadcast_no_sched </td>
          <td>(</td>
          <td class="paramtype">struct cthread_cond *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="cthread__api_8h.html#ab2f372b1c1f4b3096da53c614369f24c">cthread_cond_broadcast()</a>, but does not reschedule the threads</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Pointer to pointer to the condition variable to be signalled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 The condition was signalled ( Success ) EINVAL was not a an initialised condition variable </dd></dl>

</div>
</div>
<a id="a904e9af749c2b5d3c556db0f32ebc65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e9af749c2b5d3c556db0f32ebc65c">&#9670;&nbsp;</a></span>cthread_sema_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_sema **&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcthread__semaattr.html">cthread_semaattr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a semaphore</p>
<p>The semaphore can be used to communicate changes in the state of data shared between threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cthread__api_8h.html#a2fb2c84ba7fd6a0b70f939becf7aaef4">cthread_sema_wait()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to optional string describing the semaphore </td></tr>
    <tr><td class="paramname">s</td><td>Pointer to pointer to the semaphore to be initialized </td></tr>
    <tr><td class="paramname">attr</td><td>Pointer to optional attribute used to set the initial semaphore count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success EINVAL s is not a valid pointer EAGAIN insufficient resources </dd></dl>

</div>
</div>
<a id="a8fd35f32c493755d35c5b0787c3a4ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd35f32c493755d35c5b0787c3a4ed5">&#9670;&nbsp;</a></span>cthread_sema_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_destroy </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a semaphore</p>
<p>This function destroys a semaphore that was created with <a class="el" href="cthread__api_8h.html#a904e9af749c2b5d3c556db0f32ebc65c">cthread_sema_init()</a> and releases its resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sema</td><td>Pointer to the semaphore to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EBUSY sema is still in use EINVAL sema is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="aae0faebce635a9a07adf25ec0e07cc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0faebce635a9a07adf25ec0e07cc1d">&#9670;&nbsp;</a></span>cthread_sema_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_reset </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>sema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a semaphore to initialized state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sema</td><td>Pointer to the semaphore to be reset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL sema is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="a2fb2c84ba7fd6a0b70f939becf7aaef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb2c84ba7fd6a0b70f939becf7aaef4">&#9670;&nbsp;</a></span>cthread_sema_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_wait </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on a semaphore</p>
<p>The function blocks the current thread waiting on the semaphore specified by s. The waiting thread unblocks only after another thread calls cthread_sema_signal specifying the same semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the semaphore on which to wait </td></tr>
    <tr><td class="paramname">m</td><td>Mutex to release or NULL if no mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL s is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="a3ec89856a82e7ec497e37c4392e41031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec89856a82e7ec497e37c4392e41031">&#9670;&nbsp;</a></span>cthread_sema_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_timedwait </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct cthread_mutex *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on a semaphore with timeout</p>
<p>The function blocks the current thread waiting on the semaphore specified by s. The waiting thread unblocks only after another thread calls cthread_sema_signal specifying the same semaphore, or abstime elapses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the semaphore to be waited on </td></tr>
    <tr><td class="paramname">m</td><td>Mutex to release or NULL if no mutex. </td></tr>
    <tr><td class="paramname">abstime</td><td>Timespec used for timeout value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success CT_STATE_EXPIRED timeout expired without semaphore signal EINVAL s is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="aa308ecc946548cb0a1f75cc6a0d607c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa308ecc946548cb0a1f75cc6a0d607c8">&#9670;&nbsp;</a></span>cthread_sema_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_signal </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal a semaphore</p>
<p>The function unblocks one thread waiting for the semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the semaphore to be signalled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL s is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="afd5d9cacfdd50008c550b362e8c82c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5d9cacfdd50008c550b362e8c82c70">&#9670;&nbsp;</a></span>cthread_sema_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_flush </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush a semaphore</p>
<p>The function unblocks all threads waiting for the semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the semaphore to be flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL s is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="a5b3e5c37077435719a6e7860eb08f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3e5c37077435719a6e7860eb08f454">&#9670;&nbsp;</a></span>cthread_sema_flush_no_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sema_flush_no_sched </td>
          <td>(</td>
          <td class="paramtype">struct cthread_sema *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush a semaphore, but do not reschedule threads</p>
<p>The function unblocks all threads waiting for the semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the semaphore to be flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success EINVAL s is not an initialised semaphore </dd></dl>

</div>
</div>
<a id="a043b6df21e1c6c04c7e2b8b38ba85ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043b6df21e1c6c04c7e2b8b38ba85ff2">&#9670;&nbsp;</a></span>is_cthread_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int is_cthread_running </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current cthread is running </p>

</div>
</div>
<a id="a0a87c6859aa105f94f202fa955286999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a87c6859aa105f94f202fa955286999">&#9670;&nbsp;</a></span>cthread_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API struct <a class="el" href="structcthread.html">cthread</a>* cthread_find </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a cthread structure pointer for a given scheduler and thread id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The cthread scheduler pointer </td></tr>
    <tr><td class="paramname">threadid</td><td>The threadid value to look for on the scheduler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to cthread structure or NULL on not found </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a6">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2ae03992684d8b8d3cc3944bf515d0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae03992684d8b8d3cc3944bf515d0a6">&#9670;&nbsp;</a></span>cthread_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_foreach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cthread__api_8h.html#aba3509ebe16b0777f10c6d2adb2b1d35">cthread_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Foreach cthread on a scheduler call the function with argument</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scheduler structure pointer </td></tr>
    <tr><td class="paramname">func</td><td>The function pointer to call for each cthread </td></tr>
    <tr><td class="paramname">arg</td><td>The arg supplied by the user to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a7">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a15ae871ba888d6d9be59ed10f0569fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ae871ba888d6d9be59ed10f0569fb1">&#9670;&nbsp;</a></span>cthread_get_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API struct <a class="el" href="structcthread__sched.html">cthread_sched</a>* cthread_get_sched </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the scheduler for the cthread structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cthread structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or the <a class="el" href="structcthread__sched.html">cthread_sched</a> structure pointer. </dd></dl>

</div>
</div>
<a id="a49057fbd1754fd674ff537b05541435f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49057fbd1754fd674ff537b05541435f">&#9670;&nbsp;</a></span>cthread_sched_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sched_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread__sched.html">cthread_sched</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the scheduler ID value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scheduler structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error or scheduler ID value </dd></dl>

</div>
</div>
<a id="a1ba1580bb64195ad56d2df039197f2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba1580bb64195ad56d2df039197f2f8">&#9670;&nbsp;</a></span>cthread_sched_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API struct <a class="el" href="structcthread__sched.html">cthread_sched</a>* cthread_sched_find </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>schedid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the <a class="el" href="structcthread__sched.html">cthread_sched</a> pointer for the given sched ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedid</td><td>The schedid value to search for in the scheduler list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or pointer to <a class="el" href="structcthread__sched.html">cthread_sched</a> structure. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a3">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a1d608077a198d3422d6f0a49222394f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d608077a198d3422d6f0a49222394f2">&#9670;&nbsp;</a></span>cthread_sched_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_sched_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cthread__api_8h.html#a8cd0cbbad7cf140e8c34e442f7300e2a">sched_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all schedulers and call the function pointer with argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to callback foreach scheduler passing the argument given </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a8">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="adcd05e5d2c84ce9bd1982d5238044bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd05e5d2c84ce9bd1982d5238044bf3">&#9670;&nbsp;</a></span>cthread_thread_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API void* cthread_thread_private </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the thread private pointer or value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cthread structure pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The therad private pointer value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2main_8c-example.html#a2">examples/phil/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab0cf67ee5ec1549a043f80522275deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cf67ee5ec1549a043f80522275deac">&#9670;&nbsp;</a></span>cthread_set_thread_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_set_thread_private </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcthread.html">cthread</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a thread private pointer or value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cthread structure pointer. </td></tr>
    <tr><td class="paramname">arg</td><td>The pointer value to set in the cthread structure. The value is not used or freed on thread exit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2phil_2phil_8c-example.html#a5">examples/phil/phil.c</a>.</dd>
</dl>

</div>
</div>
<a id="abe917442e03aef51d4c149eb50af2736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe917442e03aef51d4c149eb50af2736">&#9670;&nbsp;</a></span>cthread_once_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_once_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> **&#160;</td>
          <td class="paramname"><em>once</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a once only structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">once</td><td>Pointer to pointer of a cthread_once structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>

</div>
</div>
<a id="ab90ad8624a848a3c754f0deeead50064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90ad8624a848a3c754f0deeead50064">&#9670;&nbsp;</a></span>cthread_once_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_once_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> *&#160;</td>
          <td class="paramname"><em>once</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a cthread_once structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">once</td><td>Pointer to pointer of a cthread_once structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>

</div>
</div>
<a id="ac2570dbb8124eb0d83bbace7bd52e9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2570dbb8124eb0d83bbace7bd52e9f1">&#9670;&nbsp;</a></span>cthread_once_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_once_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="cthread__api_8h.html#a38c895145d7097ee824e420f4198b221">cthread_once</a> *&#160;</td>
          <td class="paramname"><em>once</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a cthread_once structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">once</td><td>Pointer to pointer of a cthread_once structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>

</div>
</div>
<a id="a38c895145d7097ee824e420f4198b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c895145d7097ee824e420f4198b221">&#9670;&nbsp;</a></span>cthread_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CNDP_API int cthread_once </td>
          <td>(</td>
          <td class="paramtype">struct cthread_once *&#160;</td>
          <td class="paramname"><em>once</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute the function only once with the cthread_once structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">once</td><td>Pointer to pointer of a cthread_once structure </td></tr>
    <tr><td class="paramname">func</td><td>The function to call only once passsing the argument value. </td></tr>
    <tr><td class="paramname">arg</td><td>The opaque data to pass to <code>func</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aadf9fabf6ed7901ff33ecc4eea76ee64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf9fabf6ed7901ff33ecc4eea76ee64">&#9670;&nbsp;</a></span>__start_per_dt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char __start_per_dt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The macros below provide an alternative mechanism to access cthread local storage.</p>
<p>The macros can be used to declare define and access per cthread local storage in a similar way to the CNE_PER_THREAD macros which control storage local to an thread.</p>
<p>Memory for per cthread variables declared in this way is allocated when the cthread is created and a pointer to this memory is stored in the cthread. The per cthread variables are accessed via the pointer + the offset of the particular variable.</p>
<p>The total size of per cthread storage, and the variable offsets are found by defining the variables in a unique global memory section, the start and end of which is known. This global memory section is used only in the computation of the addresses of the cthread variables, and is never actually used to store any data.</p>
<p>Due to the fact that variables declared this way may be scattered across many files, the start and end of the section and variable offsets are only known after linking, thus the computation of section size and variable addresses is performed at run time.</p>
<p>These macros are primarily provided to aid porting of code that makes use of the existing CNE_PER_THREAD macros. In principle it would be more efficient to gather all cthread local variables into a single structure and set/retrieve a pointer to that struct using the alternative cthread_data_set/get APIs.</p>
<p>These macros are mutually exclusive with the cthread_data_set/get APIs. If you define storage using these macros then the cthread_data_set/get APIs will not perform as expected, the cthread_data_set API does nothing, and the cthread_data_get API returns the start of global section. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_7bbc81032548574d2e7e9264f003edf5.html">usr</a></li><li class="navelem"><a class="el" href="dir_52d0f5cebd30a8a0290be82a9cdbea18.html">clib</a></li><li class="navelem"><a class="el" href="dir_07a4eda89cd38af6f0536bcd8562bcc1.html">cthread</a></li><li class="navelem"><a class="el" href="cthread__api_8h.html">cthread_api.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
